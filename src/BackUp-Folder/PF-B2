import React from "react";
import { dijkstra } from "../algorithms/dijkstra";
import { aStarSearch } from "../algorithms/aStarSearch.js";
import { greedyBestFirstSearch } from "../algorithms/greedyBestFirstSearch.js";
import { getNodesInShortestPathOrder } from "../algorithms/getNodesInShortestPathOrder.js";
import { depthFirstSearch } from "../algorithms/depthFirstSearch.js";
import Node from "./Node/Node.jsx";
import "./PathfindingVisualizer.css";
import "./Node/Node.css";

let mouseIsPressed = false;
let mouseOnStart = false;
let mouseOnFinish = false;
let startNodeRow = 15;
let startNodeCol = 15;
let finishNodeRow = 15;
let finishNodeCol = 45;
let grid = getInitialGrid(
  startNodeRow,
  startNodeCol,
  finishNodeRow,
  finishNodeCol
);

const renderGrid = grid.map((row, rowIdx) => {
  return row.map((node, colIdx) => {
    const { row, col, isFinish, isStart, isWall } = node;
    return (
      <Node
        row={row}
        col={col}
        isFinish={isFinish}
        isStart={isStart}
        isWall={isWall}
        key={`node-${row}-${col}`}
        onMouseDown={(row, col, isStart, isFinish) => {
          handleMouseDown(row, col, isStart, isFinish);
        }}
        onMouseEnter={(row, col, isStart, isFinish) => {
          handleMouseEnter(row, col, isStart, isFinish);
        }}
        onMouseUp={(row, col) => handleMouseUp(row, col)}
        onMouseLeave={(row, col) => {
          handleMouseLeave(row, col);
        }}
      />
    );
  });
});

const PathfindingVisualizerFunctionalComponent = () => {
  return (
    <div>
      <div>
        <button onClick={() => makeAlgorithm("dijkstra")}>Dijkstra</button>
        <button onClick={() => makeAlgorithm("aStar")}>A*</button>
        <button onClick={() => makeAlgorithm("greedy")}>Greedy</button>
        <button onClick={() => makeAlgorithm("depth")}>Depth</button>
        <div className="grid">{renderGrid}</div>
      </div>
    </div>
  );
};

export default PathfindingVisualizerFunctionalComponent;

export function createNode(
  row,
  col,
  startNodeRow,
  startNodeCol,
  finishNodeRow,
  finishNodeCol
) {
  return {
    row: row,
    col: col,
    isStart: row === startNodeRow && col === startNodeCol,
    isFinish: row === finishNodeRow && col === finishNodeCol,
    isWall: false,
    distance: "Infinity",
    prevNode: "none",
    gCost: 9000000,
    hCost: 9000000,
    fCost: 9000000,
    status: 1,
  };
}

export function getInitialGrid(
  startNodeRow,
  startNodeCol,
  finishNodeRow,
  finishNodeCol
) {
  const grid = [];
  for (let i = 0; i < 31; i++) {
    let row = [];
    for (let j = 0; j < 75; j++) {
      row.push(
        createNode(
          i,
          j,
          startNodeRow,
          startNodeCol,
          finishNodeRow,
          finishNodeCol
        )
      );
    }
    grid.push(row);
  }
  return grid;
}

export function makeAlgorithm(algorithm) {
  const startNode = grid[startNodeRow][startNodeCol];
  const finishNode = grid[finishNodeRow][finishNodeCol];
  let visitedNodesInOrder;
  if (algorithm === "dijkstra") {
    visitedNodesInOrder = visitedNodesInOrder = dijkstra(
      grid,
      startNode,
      finishNode
    );
  } else if (algorithm === "aStar") {
    visitedNodesInOrder = visitedNodesInOrder = aStarSearch(
      grid,
      startNode,
      finishNode
    );
  } else if (algorithm === "greedy") {
    visitedNodesInOrder = visitedNodesInOrder = greedyBestFirstSearch(
      grid,
      startNode,
      finishNode
    );
  } else if (algorithm === "depth") {
    visitedNodesInOrder = visitedNodesInOrder = depthFirstSearch(
      grid,
      startNode,
      finishNode
    );
  }
  const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);
  animate(visitedNodesInOrder, nodesInShortestPathOrder);
}

export function animate(visitedNodesInOrder, nodesInShortestPathOrder) {
  for (let i = 0; i < visitedNodesInOrder.length; i++) {
    if (i === visitedNodesInOrder.length - 1) {
      setTimeout(() => {
        animateShortestPath(nodesInShortestPathOrder);
      }, i * 15);
    }

    if (i < visitedNodesInOrder.length - 1) {
      setTimeout(() => {
        const node = visitedNodesInOrder[i + 1];
        document.getElementById(`node-${node.row}-${node.col}`).className =
          "node-pre";
      }, 15 * i);
    }

    setTimeout(() => {
      const node = visitedNodesInOrder[i];
      document.getElementById(`node-${node.row}-${node.col}`).className =
        "node-visited";
    }, 15 * i);
  }
}

export function animateShortestPath(nodesInShortestPathOrder) {
  nodesInShortestPathOrder.shift();
  for (let i = 0; i < nodesInShortestPathOrder.length; i++) {
    setTimeout(() => {
      const node = nodesInShortestPathOrder[i];
      document.getElementById(`node-${node.row}-${node.col}`).className =
        "node-shortest-path";
    }, 15 * i);
  }
}

export function handleMouseDown(row, col, isStart, isFinish) {
  if (isStart) {
    deleteStart(grid, row, col);
    mouseOnStart = true;
  } else if (isFinish) {
    const newGrid = deleteFinish(grid, row, col);
    grid = newGrid;
    mouseOnFinish = true;
  } else {
    const newGrid = getGridWithWallToggled(grid, row, col);
    grid = newGrid;
    mouseIsPressed = true;
  }
}

export function handleMouseUp(row, col) {
  if (mouseOnStart) {
    const newGrid = makeStart(grid, row, col);
    grid = newGrid;
    mouseOnStart = false;
    startNodeRow = row;
    startNodeCol = col;
  } else if (mouseOnFinish) {
    const newGrid = makeFinish(grid, row, col);
    grid = newGrid;
    mouseOnFinish = false;
    finishNodeRow = row;
    finishNodeCol = col;
  } else {
    mouseIsPressed = false;
  }
}

export function handleMouseEnter(row, col) {
  if (mouseOnStart) {
    const newGrid = makeStart(grid, row, col);
    grid = newGrid;
    mouseOnStart = true;
    startNodeRow = row;
    startNodeCol = col;
  } else if (mouseOnFinish) {
    const newGrid = makeFinish(grid, row, col);
    grid = newGrid;
    mouseOnFinish = true;
    finishNodeRow = row;
    finishNodeCol = col;
  } else if (mouseIsPressed) {
    const newGrid = getGridWithWallToggled(grid, row, col);
    grid = newGrid;
  }
}

export function handleMouseLeave(row, col) {
  if (mouseOnStart) {
    const newGrid = deleteStart(grid, row, col);
    grid = newGrid;
  } else if (mouseOnFinish) {
    const newGrid = deleteFinish(grid, row, col);
    grid = newGrid;
  }
}

export function getGridWithWallToggled(grid, row, col) {
  const newGrid = grid.slice();
  const node = newGrid[row][col];
  const newNode = {
    ...node,
    isWall: !node.isWall,
  };
  newGrid[row][col] = newNode;
  return newGrid;
}

export function makeStart(grid, row, col) {
  const newGrid = grid.slice();
  const node = newGrid[row][col];
  const newNode = {
    ...node,
    isStart: true,
  };
  newGrid[row][col] = newNode;
  return newGrid;
  // grid[row][col].isStart = true;
}

export function makeFinish(grid, row, col) {
  const newGrid = grid.slice();
  const node = newGrid[row][col];
  const newNode = {
    ...node,
    isFinish: true,
  };
  newGrid[row][col] = newNode;
  return newGrid;
}

export function deleteStart(grid, row, col) {
  const newGrid = grid.slice();
  const node = newGrid[row][col];
  const newNode = {
    ...node,
    isStart: false,
  };
  newGrid[row][col] = newNode;
  return newGrid;
  // grid[row][col].isStart = !grid[row][col].isStart;
  // console.log(grid);
}

export function deleteFinish(grid, row, col) {
  const newGrid = grid.slice();
  const node = newGrid[row][col];
  const newNode = {
    ...node,
    isFinish: false,
  };
  newGrid[row][col] = newNode;
  return newGrid;
}
